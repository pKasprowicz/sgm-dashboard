{
  "name": "clite",
  "description": "A slight CLI framework",
  "main": "./index.js",
  "scripts": {
    "lint": "jscs lib/*.js -v",
    "check-only": "! grep 'test.only' test/**/*.test.js -n",
    "tap": "tap test/**/*.test.js --cov",
    "test": "npm run check-only && npm run lint && npm run tap",
    "cover": "tap test/**/*.test.js --cov --coverage-report=lcov && npm run check-only",
    "build": "babel lib --out-dir dist",
    "semantic-release": "semantic-release pre && npm publish && semantic-release post"
  },
  "bin": {
    "clite": "cli/index.js"
  },
  "config": {
    "validate-commit-msg": {
      "helpMessage": "\n-----------\n\nThere was a small validation problem with your commit message:\n\n> %s\n\nIt's not a huge problem, but a valid commit message will ensure\nwhether your commit triggers a release or not (and sometimes the\ncommit won't need to trigger a release). If you really need to, you\ncan skip the validation using `git commit --no-verify`.\n\nIf your commit is a fix, it might want to be:\n\n> fix: storage bug\n\nOr a feature:\n\n> feat: added new storage process\n\nThere's also `docs`, `test` and `chore` and a few more. To read\nhow the commit message should be formatted, please see this short\npost: https://git.io/v2Nnm\n"
    },
    "ghooks": {
      "commit-msg": "validate-commit-msg",
      "pre-push": "npm test"
    }
  },
  "keywords": [
    "cli",
    "terminal",
    "framework"
  ],
  "author": {
    "name": "Remy Sharp"
  },
  "license": "MIT",
  "devDependencies": {
    "babel-cli": "^6.5.1",
    "babel-preset-es2015": "^6.5.0",
    "ghooks": "^1.0.3",
    "jscs": "^2.10.1",
    "mock-stdin": "^0.3.0",
    "proxyquire": "^1.7.4",
    "rimraf": "^2.5.2",
    "semantic-release": "^4.3.5",
    "tap": "^5.4.3",
    "tap-only": "0.0.5",
    "validate-commit-msg": "^2.3.0"
  },
  "dependencies": {
    "abbrev": "^1.0.7",
    "debug": "^2.2.0",
    "es6-promise": "^3.1.2",
    "lodash.defaults": "^4.0.1",
    "lodash.defaultsdeep": "^4.3.1",
    "lodash.mergewith": "^4.3.1",
    "then-fs": "^2.0.0",
    "update-notifier": "^0.6.0",
    "yargs": "^4.3.2"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/remy/clite.git"
  },
  "version": "0.3.0",
  "readme": "# clite\n\nA CLI lite framework for your node CLI utilities. Provides basic routine functionality that you don't want to write yourself. Pronounced: *slight*.\n\n[![Build Status](https://travis-ci.org/remy/clite.svg)](https://travis-ci.org/remy/clite) [![Donate](https://img.shields.io/badge/support-%20%E2%9D%A4%20-56c838.svg)](https://www.paypal.me/rem)\n\n## Features\n\n- **version**: echo's current `package.json` version, or if omitted (if you're using [semantic-release](https://www.npmjs.com/semantic-release)) will echo the current branch & commit\n- **help**: simplifies loading and reading help files\n- **stdin**: automatically detects bodies on stdin and passes it as an argument to your code\n- **update notification**: uses [update-notifier](https://www.npmjs.com/update-notifier) to automatically notify your users of an update to your CLI tool\n- on exceptions, will echo the error and quit with a non-zero exit code\n- automatically creates aliases for all your CLI commands and options using [abbrev](https://www.npmjs.com/package/abbrev)\n- supports boolean flags, options and aliases using [yargs](https://www.npmjs.org/yargs)\n- promise based (note that promises are polyfilled in node < 4, using [es6-promise](https://www.npmjs.com/es6-promise))\n- command modules are lazy loaded, which reduces boot and exit time in your CLI tool\n\n## Usage\n\nAfter `npm install --save clite` to your project, the simplest CLI script contains:\n\n```js\n#!/usr/bin/env node\nvar clite = require('clite');\nclite(require('./config'));\n```\n\nThe config drives how your code is run from the CLI. Note that by default, clite expects your code to return a string (which will be echo'ed on `STDOUT`) or throw an error that also echos the `error.message` on `STDERR`.\n\n## Debugging\n\nTo see more details on what clite is parsing and see any stacktraces inside of clite, use the `DEBUG=clite` env value:\n\n```bash\nDEBUG=clite <your-demo-app>\n```\n\n## Return objects in commands (and async use)\n\nYour command modules are called inside of promises. The clite framework expects a `string` to be returned out of the promises to be printed on `STDOUT`.\n\nIf your command needs to make use of asnychonous programming, return a promise, and resolve the promise with a string. For example:\n\n```js\nmodule.exports = function echoLater(args) {\n  return new Promise(resolve =>\n    setTimeout(() => resolve('All done'), 1000)\n  );\n};\n```\n\n## Config\n\nThe configuration is made up of the following properties:\n\n- commands: a map of CLI arguments to JavaScript files\n- booleans: an array of arguments you wish to accept as boolean values\n- options: an array of arguments you wish to accept as strings (or numbers)\n- alias: a map of alias keys (the CLI alias) and values (the real value)\n- help: either a filename, or a map of keys and values to text filenames\n- return: defaulted to false, returns all values, errors included, to user code (by default exceptions cause a `process.exit(1)`)\n\n**Important**: all filenames (for help and commands) are relative to the root of your package.json file.\n\nFor `commands` and `help`, a special key of `_` that is used if no argument is given (i.e. your user runs your CLI utility without any arguments).\n\nA sample config can be seen in the [example](#example) section below.\n\n## Commands\n\nThe commands are the mapping from the CLI argument to your scripts. An example `commands` in the config could be:\n\n```js\nmodule.exports = {\n  commands: {\n    '_': 'lib/index',\n    'publish': 'lib/publish',\n    'search': 'lib/search',\n    'new': 'lib/create-new-post'\n  },\n  // snip\n```\n\nAlthough clite uses promises, your code does not need to use them (but you can if chose to), however, if you `throw` an error, this will echo to the terminal and `exit(1)` the program. The commands modules receive three arguments:\n\n- `args`: an object of the fully parsed CLI arguments, all command arguments are stored in `args._` as an array (note that the array only contains all the remaining args not matched to flags or commands)\n- `settings`: the configuration of clite (including defaults)\n- `body`: the body of text if content was piped via `STDIN`\n\nFor example, `lib/create-new-post` could contain:\n\n```js\nmodule.exports = (args, settings, body) => {\n  if (body) {\n    // create the post in the db\n    return new Post({\n      body,\n      title: args._[0]\n    }).save().then(r => `Successfully created ${r.id}`);\n  }\n};\n\n// called using `cat post.md | my-cli-tool new \"Awesome Post Title\"\n```\n\nThis also assumes that your bin script is using `.then(console.log)` to redirect responses to the terminal. Of course, you don't have to do that, you can handle printing to the terminal as you please.\n\n## Example\n\nDirectory structure:\n\n```text\nclite-demo\n├── cli\n│   ├── config.js\n│   └── index.js\n├── help\n│   ├── help.txt\n│   └── setup.txt\n├── lib\n│   ├── search.js\n│   ├── publish.js\n│   ├── create-new-post.js\n│   └── index.js\n├── node_modules\n│   └── clite <snip>\n└── package.json\n```\n\nSnippet of `package.json`:\n\n```json\n{\n  \"name\": \"clite-demo\",\n  \"main\": \"lib/index.js\",\n  \"dependencies\": {\n    \"clite\": \"^1.0.0\"\n  },\n  \"bin\": {\n    \"clite-demo\": \"cli/index.js\"\n  }\n}\n```\n\nContents of `cli/index.js` (which is linked to the bin file `clite-demo`):\n\n```js\n#!/usr/bin/env node\nvar clite = require('clite');\nclite(require('./config')).then(console.log);\n```\n\nContents of `cli/config.js`:\n\n```js\nmodule.exports = {\n  commands: {\n    '_': 'lib/index',\n    'publish': 'lib/publish',\n    'search': 'lib/search',\n    'new': 'lib/create-new-post'\n  },\n  option: [\n    'grep',\n    'count',\n  ],\n  flag: [\n    'debug',\n    'json'\n  ],\n  help: {\n    _: 'help/help.txt',\n    setup: 'help/setup.txt'\n  },\n};\n```\n\n**Important note:** where `_` is used, this is the fallback for if the user has not specified a value for a particular command. If the default is not found, clite will revert to loading \"`.`\" (aka the index of package directory).\n\n## FAQTIMU\n\nFrequently asked questions...that I made up:\n\n### I see `undefined` at the end of the output\n\nThis is because clite is logging out your content, then your code is including a final log, such as:\n\n```js\nclite(require('./config')).then(console.log);\n```\n\nTo fix this, remove the final `.then(console.log)`.\n\n### Can I get the original CLI arguments?\n\nThe original CLI args is on `process.argv`, if you want everything that wasn't a boolean or an option, then this is in the command's `arg.argv` - which is usually the same as `arg._` except doesn't contain the path to `node`, the script that ran the code and if a command was matched, that command.\n\n## Feedback, filing issues & pull requests\n\nPlease see the [contributing](https://github.com/remy/clite/blob/master/.github/CONTRIBUTING.md) for guidelines. All feedback is welcome ❤\n\n## License\n\nMIT / http://rem.mit-license.org",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/remy/clite/issues"
  },
  "_id": "clite@0.3.0",
  "dist": {
    "shasum": "25de316ce1193024dcdfc716d60617804f6b61e2"
  },
  "_from": "clite@^0.3.0",
  "_resolved": "https://registry.npmjs.org/clite/-/clite-0.3.0.tgz"
}
